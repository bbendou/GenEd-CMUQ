{"code": "15-414", "name": "Bug Catching: Automated Program Verification", "base_name": "Bug Catching: Automated Program Verification", "units": 9.0, "min_units": 9.0, "max_units": 9.0, "short_name": "BUG CATCHING", "is_topic": false, "topic": null, "prereqs": {"text": "(15-122 [] at least C) and (15-251 [] at least C)", "req_obj": {"id": 7906979, "screen_name": "0ev9a4cxdzmrgt3", "original_min_units": null, "min_units": null, "is_shared": false, "is_uni_req": false, "is_concentration": false, "default_concentration": false, "choices": [{"id": 7906980, "screen_name": "7rhzk8911y5vvzh", "original_min_units": null, "min_units": null, "is_shared": false, "is_uni_req": false, "is_concentration": false, "default_concentration": false, "choices": [{"id": 2154, "screen_name": "15-122", "constraints": [{"type": "course", "type_string": "", "data": {"course": {"code": "15-122", "id": 2153, "name": "Principles of Imperative Computation", "units": 12.0}}, "id": 2153, "is_hidden": false}], "course_parent_id": "79069800000000002154"}], "constraints": [{"type": "anyxof", "type_string": "Fulfill all of the following requirements", "data": {"x": 1, "is_and": true}, "id": 10931613, "is_hidden": false}, {"type": "mingrade", "type_string": "Minimum grade of C", "data": {"grade": "C", "only_transfer_status": false, "only_non_transfer_status": false}, "id": 10931614, "is_hidden": false}]}, {"id": 7906981, "screen_name": "6exnks622ckr58z", "original_min_units": null, "min_units": null, "is_shared": false, "is_uni_req": false, "is_concentration": false, "default_concentration": false, "choices": [{"id": 2670, "screen_name": "15-251", "constraints": [{"type": "course", "type_string": "", "data": {"course": {"code": "15-251", "id": 2669, "name": "Great Ideas in Theoretical Computer Science", "units": 12.0}}, "id": 2669, "is_hidden": false}], "course_parent_id": "79069810000000002670"}], "constraints": [{"type": "anyxof", "type_string": "Fulfill all of the following requirements", "data": {"x": 1, "is_and": true}, "id": 10931615, "is_hidden": false}, {"type": "mingrade", "type_string": "Minimum grade of C", "data": {"grade": "C", "only_transfer_status": false, "only_non_transfer_status": false}, "id": 10931616, "is_hidden": false}]}], "constraints": [{"type": "anyxof", "type_string": "Fulfill all of the following requirements", "data": {"x": 2, "is_and": true}, "id": 10931612, "is_hidden": false}]}, "raw_pre_req": ""}, "offered_in_campuses": [1], "offerings": [{"campus_id": 1, "semesters": [{"semester": 2, "year": 2022}, {"semester": 2, "year": 2023}, {"semester": 2, "year": 2024}, {"semester": 2, "year": 2025}, {"semester": 1, "year": 2025}], "sub_semesters": []}], "co_reqs": [], "anti_reqs": [], "equiv": [], "long_desc": "Many CS and ECE students will be developing software and hardware that must be ultra reliable at some point in their careers. Logical errors in such designs can be costly, even life threatening. There have already been a number of well publicized errors like the Intel Pentium floating point error and the Arian 5 crash. In this course we will study tools for finding and preventing logical errors. Three types of tools will be studied automated theorem proving, state exploration techniques like model checking and tools based on static program analysis. Although students will learn the theoretical basis for such tools, the emphasis will be on actually using them on real examples.  This course can be used to satisfy the Logic  Languages requirement for the Computer Science major.", "student_sets": [{"id": 896, "name": "undergraduate"}], "offering_tags": [{"name": "specific_sem", "type": "INFO", "sem": 2}], "website": "http://www.cs.cmu.edu/~15414/", "instructors": [], "is_repeatable": false, "is_req_repeatable": false, "repeat_limit_attempts": null, "repeat_limit_credits": null, "catalog_levels": [], "skills": [{"name": "Automation", "slug": "automation", "id": 22}, {"name": "Statics", "slug": "statics", "id": 813}], "attributes": [{"name": "collaboration & teamwork", "id": 21, "type": "attribute"}], "custom_fields": {"goals": "Identifying and formalizing program correctness. Understanding how to write correct software from the ground up using formal principles. Apply rigorous reasoning to program correctness. Experience using automated tools to assist in verifying real code. Understanding how modern verification tools work.", "key_topics": "- Rigorous reasoning applied to program correctness\n- Deductive program verification\n- Model checking\n- Formal specification", "prerequisite_knowledge": "- Experience programming in imperative languages\n- Basic understanding of contracts and invariants, as developed in 15-122", "assessment_structure": "40% Labs, 25% Written homework, 15% midterm exam, 15% final exam, 5% participation", "relevance": "15-414 is for undergraduates. Graduate students should enroll in 15-615.\n\nBugs can lead to reliability, safety and security issues within systems which can cost valuable resources, especially in industry. This course develops key skills needed to develop practical software that does not suffer from these problems.", "learning_resources": "- Course notes provided by instructors\n- Piazza\n- Gradescope\n- Autolab\n- Optional textbook available digitally through the library", "extra_time_commitment": null}, "admin_context": {"suggested_by_advisor": null, "counts_for": []}, "success": true}